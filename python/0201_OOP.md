# :thinking: OOP_I :thinking:

* Python에서 모든 것은 객체이다. `type` `attribute` `method`

  

* 모든 객체는 특정 타입의 인스턴스이다.

  * 10은 int의 인스턴스이다. `isinstance(10, int)` `type(10) == int`

    

* `dir`(객체) : 객체가 활용가능한 메서드를 보여줌



##  메타클래스 :older_man:

1. class : 객체들의 분류를 `정의`할 때  쓰는 키워드 `type(class명) == type`

2. type : 공통 속성을 가진 객체들의 `분류` (class)

>  : 메타클래스(metaclass)
>
> 파이썬의 모든 것은 객체다. 객체는 클래스를 토대로 만들어진다.
>
> 근데 클래스도 객체다. 그럼 클래스 객체는 무엇으로 만들지...?
>
> * **클래스를 만드는 클래스** (`<class 'type'>`)
> * type이라는 메타클래스는 재귀적으로 자신을 클래스로 삼게끔 설계되어 있다. 
>
> ````python
> type(int) == type
> type(type) == type
> ````

---



# :thinking: OOP_II :thinking:

## 1.  인스턴스 클래스 메서드 :dog:

### 1.1 인스턴스 클래스

``` python
class Puppy:
    population = 0
    
    # 생성자 메서드
    def __init__(self, name, breed = '멍멍이'):
        self.name = name
        self.breed = breed
        Puppy.population += 1
```

* name : 인스턴스 변수(속성) - 각 인스턴스에 저장되야 하는 속성

* population : 클래스 변수 

  * 모든 인스턴스가 공유
  * :exclamation: p1.population으로 호출가능 (같은 이름의 인스턴스 변수가 없기 때문에 이름공간 참고) 
  * :exclamation: p1.population 새롭게 할당가능

  

```python
# 인스턴스 생성 => 인스턴스 = 클래스()
p1 = Puppy('초코', '푸들')
p2 = Puppy('댕댕이', '시츄')
type(p1) # __main__.Puppy 사용자가 정의한 Puppy라는 type
```

>  p1, p2 : 클래스 Puppy의 인스턴스



### 1.2 메서드 :dog2:

```python
	def bark(self):
        print(f'멍멍 {self.name}! 내 친구는 {Puppy.population}마리야')
    
    # 스태틱 메서드
    @staticmethod
    def info():
        print('우리집 강아지입니다. >_<')
        
    @classmethod
    def get_population(cls):
        print(f'{cls.population}')
        
    # 소멸자 메서드 : del p1 실행시 호출됨
    def __del__(self):
        Puppy.population -= 1
```

* bark() : 인스턴스 메서드

* get_population() : 클래스 메서드

  > :exclamation: 메서드에서 인스턴스 변수와 클래스 변수를 동시에 사용할 때는 호출하는 객체가 무엇일지 생각하면 된다.

  

```python
p1.bark()
```

* def bark(self)에서 `self`는 함수 호출 시

  : p1. bark() -> balk(p1)  인스턴스 자기자신을 인자로 전달된다.  :hotdog:



```python
def __str__(self):
    return '객체를 print할 때 보여줄 내용'

def __repr__(self):
    return '객체를 return할 때 보여줄 내용'
```

> 매직메서드 : `__something__`



## 2. :grey_question: 인스턴스 & 클래스 이름공간 :grey_question:

인스턴스에서 특정한 변수에 접근하면 **인스턴스 => 클래스** 순으로 탐색

### 2.1 `.`을 사용하는 기준

 :question:

> 변수명. 함수명 :  함수를 호출할 때 `.`을 사용한다고 생각했는데 정확한 쓰임은?

 :a:  

 클래스에서 인스턴스를 만들게 되면, 

 클래스에 정의되어 있는 '데이터' (속성) 와 '기능' (메서드) 을 사용할 수 있다!
 ```python
 class 학생:
 학년 = 뭐시기
 
 def 공부한다():
    뭐시기

 def 학생():
     어쩌구
 ```

 가은 = 학생()

 가은이라는 인스턴스가 데이터에 접근할 때 `가은.학년`

 기능에 접근할 때 `가은.공부한다()`

 :arrow_forward: `.`를 통해서 해당 클래스, 해당 객체 내에 데이터, 기능에 접근할 수 있다.



### 2.2 `()`의 사용

:question:

> 1. 함수를 사용할 때 `()`를 사용하는 거 아닌가요? 
>      왜 인스턴스를 정의할 때도 쓰이고, 
> 2. 어떻게 **구분**할 수 있는 건가요?

:a: 

1. 학생이라는 클래스가 존재할 때, 클래스로 인스턴스를 만드는 문법이 

  인스턴스1 = 클래스명() 	`가은 = 학생()` 

   (메서드는 아님! 동일하게 소괄호를 사용할 뿐)

2. 학생을 추적했을 때, 이름공간에 따라 학생을 부른 장소자체가 다르다 :exclamation:

  * `가은 = 학생()` 처럼 클래스면 

    인스턴스를 생성하는 문법으로 인식한다.

    => 전역 공간에 있는 클래스를 통해 인스턴스 생성

  * `가은.학생()`처럼 인스턴스의 메서드이면 

    메서드로 실행

    => 가은이라는 인스턴스가 메서드를 호출

---



# :thinking: OOP_III :thinking:

##  1. 상속 :family_man_girl_boy:

